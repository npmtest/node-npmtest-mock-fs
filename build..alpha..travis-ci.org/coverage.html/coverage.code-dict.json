{"/home/travis/build/npmtest/node-npmtest-mock-fs/test.js":"/* istanbul instrument in package npmtest_mock_fs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-mock-fs/lib.npmtest_mock_fs.js":"/* istanbul instrument in package npmtest_mock_fs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_mock_fs = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_mock_fs = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-mock-fs/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-mock-fs && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_mock_fs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_mock_fs\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_mock_fs.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_mock_fs.rollup.js'] =\n            local.assetsDict['/assets.npmtest_mock_fs.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_mock_fs.__dirname + '/lib.npmtest_mock_fs.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-mock-fs/node_modules/mock-fs/lib/index.js":"'use strict';\n\nvar Binding = require('./binding');\nvar FSError = require('./error');\nvar FileSystem = require('./filesystem');\nvar realBinding = process.binding('fs');\nvar path = require('path');\n\n\nvar realBindingProps = Object.assign({}, realBinding);\nvar realProcessProps = {\n  cwd: process.cwd,\n  chdir: process.chdir\n};\n\nfunction overrideBinding(binding) {\n  for (var key in binding) {\n    if (typeof binding[key] === 'function') {\n      realBinding[key] = binding[key].bind(binding);\n    } else {\n      realBinding[key] = binding[key];\n    }\n  }\n}\n\nfunction overrideProcess(cwd, chdir) {\n  process.cwd = cwd;\n  process.chdir = chdir;\n}\n\nfunction restoreBinding() {\n  var key;\n  for (key in realBindingProps) {\n    realBinding[key] = realBindingProps[key];\n  }\n  // Delete excess keys that came in when the binding was originally applied.\n  for (key in realBinding) {\n    if (typeof realBindingProps[key] === 'undefined') {\n      delete realBinding[key];\n    }\n  }\n}\n\nfunction restoreProcess() {\n  for (var key in realProcessProps) {\n    process[key] = realProcessProps[key];\n  }\n}\n\n/**\n * Swap out the fs bindings for a mock file system.\n * @param {Object} config Mock file system configuration.\n * @param {Object} options Any filesystem options.\n * @param {boolean} options.createCwd Create a directory for `process.cwd()`\n *     (defaults to `true`).\n * @param {boolean} options.createTmp Create a directory for `os.tmpdir()`\n *     (defaults to `true`).\n */\nvar exports = module.exports = function mock(config, options) {\n  var system = FileSystem.create(config, options);\n  var binding = new Binding(system);\n\n  overrideBinding(binding);\n\n  var currentPath = process.cwd();\n  overrideProcess(\n    function cwd() {\n      return currentPath;\n    },\n    function chdir(directory) {\n      if (!binding.stat(path._makeLong(directory)).isDirectory()) {\n        throw new FSError('ENOTDIR');\n      }\n      currentPath = path.resolve(currentPath, directory);\n    }\n  );\n};\n\n/**\n * Get hold of the mocked filesystem's 'root'\n * If fs hasn't currently been replaced, this will return an empty object\n */\nexports.getMockRoot = function() {\n  if (typeof realBinding.getSystem === 'undefined') {\n    return {};\n  } else {\n    return realBinding.getSystem().getRoot();\n  }\n};\n\n/**\n * Restore the fs bindings for the real file system.\n */\nexports.restore = function() {\n  restoreBinding();\n  restoreProcess();\n};\n\n\n/**\n * Create a file factory.\n */\nexports.file = FileSystem.file;\n\n\n/**\n * Create a directory factory.\n */\nexports.directory = FileSystem.directory;\n\n\n/**\n * Create a symbolic link factory.\n */\nexports.symlink = FileSystem.symlink;\n","/home/travis/build/npmtest/node-npmtest-mock-fs/node_modules/mock-fs/lib/binding.js":"'use strict';\n\nvar path = require('path');\n\nvar File = require('./file');\nvar FileDescriptor = require('./descriptor');\nvar Directory = require('./directory');\nvar SymbolicLink = require('./symlink');\nvar FSError = require('./error');\nvar constants = require('constants');\nvar getPathParts = require('./filesystem').getPathParts;\n\n\n/**\n * Call the provided function and either return the result or call the callback\n * with it (depending on if a callback is provided).\n * @param {function()} callback Optional callback.\n * @param {Object} thisArg This argument for the following function.\n * @param {function()} func Function to call.\n * @return {*} Return (if callback is not provided).\n */\nfunction maybeCallback(callback, thisArg, func) {\n  if (callback && (typeof callback === 'function' || typeof callback.oncomplete === 'function')) {\n    var err = null;\n    var val;\n    try {\n      val = func.call(thisArg);\n    } catch (e) {\n      err = e;\n    }\n    // Unpack callback from FSReqWrap\n    if (callback.oncomplete) {\n      callback = callback.oncomplete.bind(callback);\n    }\n    process.nextTick(function() {\n      if (val === undefined) {\n        callback(err);\n      } else {\n        callback(err, val);\n      }\n    });\n  } else {\n    return func.call(thisArg);\n  }\n}\n\nfunction notImplemented() {\n  throw new Error('Method not implemented');\n}\n\n\n/**\n * Create a new stats object.\n * @param {Object} config Stats properties.\n * @constructor\n */\nfunction Stats(config) {\n  for (var key in config) {\n    this[key] = config[key];\n  }\n}\n\n\n/**\n * Check if mode indicates property.\n * @param {number} property Property to check.\n * @return {boolean} Property matches mode.\n */\nStats.prototype._checkModeProperty = function(property) {\n  return ((this.mode & constants.S_IFMT) === property);\n};\n\n\n/**\n * @return {Boolean} Is a directory.\n */\nStats.prototype.isDirectory = function() {\n  return this._checkModeProperty(constants.S_IFDIR);\n};\n\n\n/**\n * @return {Boolean} Is a regular file.\n */\nStats.prototype.isFile = function() {\n  return this._checkModeProperty(constants.S_IFREG);\n};\n\n\n/**\n * @return {Boolean} Is a block device.\n */\nStats.prototype.isBlockDevice = function() {\n  return this._checkModeProperty(constants.S_IFBLK);\n};\n\n\n/**\n * @return {Boolean} Is a character device.\n */\nStats.prototype.isCharacterDevice = function() {\n  return this._checkModeProperty(constants.S_IFCHR);\n};\n\n\n/**\n * @return {Boolean} Is a symbolic link.\n */\nStats.prototype.isSymbolicLink = function() {\n  return this._checkModeProperty(constants.S_IFLNK);\n};\n\n\n/**\n * @return {Boolean} Is a named pipe.\n */\nStats.prototype.isFIFO = function() {\n  return this._checkModeProperty(constants.S_IFIFO);\n};\n\n\n/**\n * @return {Boolean} Is a socket.\n */\nStats.prototype.isSocket = function() {\n  return this._checkModeProperty(constants.S_IFSOCK);\n};\n\n\n/**\n * Create a new binding with the given file system.\n * @param {FileSystem} system Mock file system.\n * @constructor\n */\nfunction Binding(system) {\n\n  /**\n   * Mock file system.\n   * @type {FileSystem}\n   */\n  this._system = system;\n\n  /**\n   * Stats constructor.\n   * @type {function}\n   */\n  this.Stats = Stats;\n\n  /**\n   * Lookup of open files.\n   * @type {Object.<number, FileDescriptor>}\n   */\n  this._openFiles = {};\n\n  /**\n   * Counter for file descriptors.\n   * @type {number}\n   */\n  this._counter = 0;\n\n}\n\n\n/**\n * Get the file system underlying this binding.\n * @return {FileSystem} The underlying file system.\n */\nBinding.prototype.getSystem = function() {\n  return this._system;\n};\n\n\n/**\n * Reset the file system underlying this binding.\n * @param {FileSystem} system The new file system.\n */\nBinding.prototype.setSystem = function(system) {\n  this._system = system;\n};\n\n\n/**\n * Get a file descriptor.\n * @param {number} fd File descriptor identifier.\n * @return {FileDescriptor} File descriptor.\n */\nBinding.prototype._getDescriptorById = function(fd) {\n  if (!this._openFiles.hasOwnProperty(fd)) {\n    throw new FSError('EBADF');\n  }\n  return this._openFiles[fd];\n};\n\n\n/**\n * Keep track of a file descriptor as open.\n * @param {FileDescriptor} descriptor The file descriptor.\n * @return {number} Identifier for file descriptor.\n */\nBinding.prototype._trackDescriptor = function(descriptor) {\n  var fd = ++this._counter;\n  this._openFiles[fd] = descriptor;\n  return fd;\n};\n\n\n/**\n * Stop tracking a file descriptor as open.\n * @param {number} fd Identifier for file descriptor.\n */\nBinding.prototype._untrackDescriptorById = function(fd) {\n  if (!this._openFiles.hasOwnProperty(fd)) {\n    throw new FSError('EBADF');\n  }\n  delete this._openFiles[fd];\n};\n\n\n/**\n * Resolve the canonicalized absolute pathname.\n * @param {string|Buffer} filepath The file path.\n * @param {string} encoding The encoding for the return.\n * @return {string|Buffer} The real path.\n */\nBinding.prototype.realpath = function(filepath, encoding, callback) {\n  return maybeCallback(callback, this, function() {\n    var realPath;\n    if (Buffer.isBuffer(filepath)) {\n      filepath = filepath.toString();\n    }\n    var resolved = path.resolve(filepath);\n    var parts = getPathParts(resolved);\n    var item = this._system.getRoot();\n    var itemPath = '/';\n    var name, i, ii;\n    for (i = 0, ii = parts.length; i < ii; ++i) {\n      name = parts[i];\n      while (item instanceof SymbolicLink) {\n        itemPath = path.resolve(path.dirname(itemPath), item.getPath());\n        item = this._system.getItem(itemPath);\n      }\n      if (!item) {\n        throw new FSError('ENOENT', filepath);\n      }\n      if (item instanceof Directory) {\n        itemPath = path.resolve(itemPath, name);\n        item = item.getItem(name);\n      } else {\n        throw new FSError('ENOTDIR', filepath);\n      }\n    }\n    if (item) {\n      while (item instanceof SymbolicLink) {\n        itemPath = path.resolve(path.dirname(itemPath), item.getPath());\n        item = this._system.getItem(itemPath);\n      }\n      realPath = itemPath;\n    } else {\n      throw new FSError('ENOENT', filepath);\n    }\n\n    if (encoding === 'buffer') {\n      realPath = new Buffer(realPath);\n    }\n    return realPath;\n  });\n};\n\n/**\n * Fill a Float64Array with stat information\n * This is based on the internal FillStatsArray function in Node.\n * https://github.com/nodejs/node/blob/4e05952a8a75af6df625415db612d3a9a1322682/src/node_file.cc#L533\n * @param {object} stats An object with file stats\n * @param {Float64Array} statValues A Float64Array where stat values should be inserted\n * @returns {void}\n */\nfunction fillStatsArray(stats, statValues) {\n  statValues[0] = stats.dev;\n  statValues[1] = stats.mode;\n  statValues[2] = stats.nlink;\n  statValues[3] = stats.uid;\n  statValues[4] = stats.gid;\n  statValues[5] = stats.rdev;\n  statValues[6] = stats.blksize;\n  statValues[7] = stats.ino;\n  statValues[8] = stats.size;\n  statValues[9] = stats.blocks;\n  statValues[10] = +stats.atime;\n  statValues[11] = +stats.mtime;\n  statValues[12] = +stats.ctime;\n  statValues[13] = +stats.birthtime;\n}\n\n/**\n * Stat an item.\n * @param {string} filepath Path.\n * @param {function(Error, Stats)|Float64Array} callback Callback (optional). In Node 7.7.0+ this will be a Float64Array\n * that should be filled with stat values.\n * @return {Stats|undefined} Stats or undefined (if sync).\n */\nBinding.prototype.stat = function(filepath, callback) {\n  return maybeCallback(callback, this, function() {\n    var item = this._system.getItem(filepath);\n    if (item instanceof SymbolicLink) {\n      item = this._system.getItem(\n          path.resolve(path.dirname(filepath), item.getPath()));\n    }\n    if (!item) {\n      throw new FSError('ENOENT', filepath);\n    }\n    var stats = item.getStats();\n\n    // In Node 7.7.0+, binding.stat accepts a Float64Array as the second argument,\n    // which should be filled with stat values.\n    // In prior versions of Node, binding.stat simply returns a Stats instance.\n    if (callback instanceof Float64Array) {\n      fillStatsArray(stats, callback);\n    } else {\n      return new Stats(stats);\n    }\n  });\n};\n\n\n/**\n * Stat an item.\n * @param {number} fd File descriptor.\n * @param {function(Error, Stats)|Float64Array} callback Callback (optional). In Node 7.7.0+ this will be a Float64Array\n * that should be filled with stat values.\n * @return {Stats|undefined} Stats or undefined (if sync).\n */\nBinding.prototype.fstat = function(fd, callback) {\n  return maybeCallback(callback, this, function() {\n    var descriptor = this._getDescriptorById(fd);\n    var item = descriptor.getItem();\n    var stats = item.getStats();\n\n    // In Node 7.7.0+, binding.stat accepts a Float64Array as the second argument,\n    // which should be filled with stat values.\n    // In prior versions of Node, binding.stat simply returns a Stats instance.\n    if (callback instanceof Float64Array) {\n      fillStatsArray(stats, callback);\n    } else {\n      return new Stats(stats);\n    }\n  });\n};\n\n\n/**\n * Close a file descriptor.\n * @param {number} fd File descriptor.\n * @param {function(Error)} callback Callback (optional).\n */\nBinding.prototype.close = function(fd, callback) {\n  maybeCallback(callback, this, function() {\n    this._untrackDescriptorById(fd);\n  });\n};\n\n\n/**\n * Open and possibly create a file.\n * @param {string} pathname File path.\n * @param {number} flags Flags.\n * @param {number} mode Mode.\n * @param {function(Error, string)} callback Callback (optional).\n * @return {string} File descriptor (if sync).\n */\nBinding.prototype.open = function(pathname, flags, mode, callback) {\n  return maybeCallback(callback, this, function() {\n    var descriptor = new FileDescriptor(flags);\n    var item = this._system.getItem(pathname);\n    while (item instanceof SymbolicLink) {\n      item = this._system.getItem(\n          path.resolve(path.dirname(pathname), item.getPath()));\n    }\n    if (descriptor.isExclusive() && item) {\n      throw new FSError('EEXIST', pathname);\n    }\n    if (descriptor.isCreate() && !item) {\n      var parent = this._system.getItem(path.dirname(pathname));\n      if (!parent) {\n        throw new FSError('ENOENT', pathname);\n      }\n      if (!(parent instanceof Directory)) {\n        throw new FSError('ENOTDIR', pathname);\n      }\n      item = new File();\n      if (mode) {\n        item.setMode(mode);\n      }\n      parent.addItem(path.basename(pathname), item);\n    }\n    if (descriptor.isRead()) {\n      if (!item) {\n        throw new FSError('ENOENT', pathname);\n      }\n      if (!item.canRead()) {\n        throw new FSError('EACCES', pathname);\n      }\n    }\n    if (descriptor.isWrite() && !item.canWrite()) {\n      throw new FSError('EACCES', pathname);\n    }\n    if (descriptor.isTruncate()) {\n      item.setContent('');\n    }\n    if (descriptor.isTruncate() || descriptor.isAppend()) {\n      descriptor.setPosition(item.getContent().length);\n    }\n    descriptor.setItem(item);\n    return this._trackDescriptor(descriptor);\n  });\n};\n\n\n/**\n * Read from a file descriptor.\n * @param {string} fd File descriptor.\n * @param {Buffer} buffer Buffer that the contents will be written to.\n * @param {number} offset Offset in the buffer to start writing to.\n * @param {number} length Number of bytes to read.\n * @param {?number} position Where to begin reading in the file.  If null,\n *     data will be read from the current file position.\n * @param {function(Error, number, Buffer)} callback Callback (optional) called\n *     with any error, number of bytes read, and the buffer.\n * @return {number} Number of bytes read (if sync).\n */\nBinding.prototype.read = function(fd, buffer, offset, length, position,\n    callback) {\n  return maybeCallback(callback, this, function() {\n    var descriptor = this._getDescriptorById(fd);\n    if (!descriptor.isRead()) {\n      throw new FSError('EBADF');\n    }\n    var file = descriptor.getItem();\n    if (!(file instanceof File)) {\n      // deleted or not a regular file\n      throw new FSError('EBADF');\n    }\n    if (typeof position !== 'number' || position < 0) {\n      position = descriptor.getPosition();\n    }\n    var content = file.getContent();\n    var start = Math.min(position, content.length);\n    var end = Math.min(position + length, content.length);\n    var read = (start < end) ? content.copy(buffer, offset, start, end) : 0;\n    descriptor.setPosition(position + read);\n    return read;\n  });\n};\n\n\n/**\n * Write to a file descriptor given a buffer.\n * @param {string} fd File descriptor.\n * @param {Array<Buffer>} buffers Array of buffers with contents to write.\n * @param {?number} position Where to begin writing in the file.  If null,\n *     data will be written to the current file position.\n * @param {function(Error, number, Buffer)} callback Callback (optional) called\n *     with any error, number of bytes written, and the buffer.\n * @return {number} Number of bytes written (if sync).\n */\nBinding.prototype.writeBuffers = function(fd, buffers, position, callback) {\n  return maybeCallback(callback, this, function() {\n    var descriptor = this._getDescriptorById(fd);\n    if (!descriptor.isWrite()) {\n      throw new FSError('EBADF');\n    }\n    var file = descriptor.getItem();\n    if (!(file instanceof File)) {\n      // not a regular file\n      throw new FSError('EBADF');\n    }\n    if (typeof position !== 'number' || position < 0) {\n      position = descriptor.getPosition();\n    }\n    var content = file.getContent();\n    var newContent = Buffer.concat(buffers);\n    var newLength = position + newContent.length;\n    if (content.length < newLength) {\n      var tempContent = new Buffer(newLength);\n      content.copy(tempContent);\n      content = tempContent;\n    }\n    var written = newContent.copy(content, position);\n    file.setContent(content);\n    descriptor.setPosition(newLength);\n    return written;\n  });\n};\n\n\n/**\n * Write to a file descriptor given a buffer.\n * @param {string} fd File descriptor.\n * @param {Buffer} buffer Buffer with contents to write.\n * @param {number} offset Offset in the buffer to start writing from.\n * @param {number} length Number of bytes to write.\n * @param {?number} position Where to begin writing in the file.  If null,\n *     data will be written to the current file position.\n * @param {function(Error, number, Buffer)} callback Callback (optional) called\n *     with any error, number of bytes written, and the buffer.\n * @return {number} Number of bytes written (if sync).\n */\nBinding.prototype.writeBuffer = function(fd, buffer, offset, length, position,\n    callback) {\n  return maybeCallback(callback, this, function() {\n    var descriptor = this._getDescriptorById(fd);\n    if (!descriptor.isWrite()) {\n      throw new FSError('EBADF');\n    }\n    var file = descriptor.getItem();\n    if (!(file instanceof File)) {\n      // not a regular file\n      throw new FSError('EBADF');\n    }\n    if (typeof position !== 'number' || position < 0) {\n      position = descriptor.getPosition();\n    }\n    var content = file.getContent();\n    var newLength = position + length;\n    if (content.length < newLength) {\n      var newContent = new Buffer(newLength);\n      content.copy(newContent);\n      content = newContent;\n    }\n    var sourceEnd = Math.min(offset + length, buffer.length);\n    var written = buffer.copy(content, position, offset, sourceEnd);\n    file.setContent(content);\n    descriptor.setPosition(newLength);\n    return written;\n  });\n};\n\n\n/**\n * Alias for writeBuffer (used in Node <= 0.10).\n * @param {string} fd File descriptor.\n * @param {Buffer} buffer Buffer with contents to write.\n * @param {number} offset Offset in the buffer to start writing from.\n * @param {number} length Number of bytes to write.\n * @param {?number} position Where to begin writing in the file.  If null,\n *     data will be written to the current file position.\n * @param {function(Error, number, Buffer)} callback Callback (optional) called\n *     with any error, number of bytes written, and the buffer.\n * @return {number} Number of bytes written (if sync).\n */\nBinding.prototype.write = Binding.prototype.writeBuffer;\n\n\n/**\n * Write to a file descriptor given a string.\n * @param {string} fd File descriptor.\n * @param {string} string String with contents to write.\n * @param {number} position Where to begin writing in the file.  If null,\n *     data will be written to the current file position.\n * @param {string} encoding String encoding.\n * @param {function(Error, number, string)} callback Callback (optional) called\n *     with any error, number of bytes written, and the string.\n * @return {number} Number of bytes written (if sync).\n */\nBinding.prototype.writeString = function(fd, string, position, encoding,\n    callback) {\n  var buffer = new Buffer(string, encoding);\n  var wrapper;\n  if (callback) {\n    if (callback.oncomplete) {\n      callback = callback.oncomplete.bind(callback);\n    }\n    wrapper = function(err, written, returned) {\n      callback(err, written, returned && string);\n    };\n  }\n  return this.writeBuffer(fd, buffer, 0, string.length, position, wrapper);\n};\n\n\n/**\n * Rename a file.\n * @param {string} oldPath Old pathname.\n * @param {string} newPath New pathname.\n * @param {function(Error)} callback Callback (optional).\n * @return {undefined}\n */\nBinding.prototype.rename = function(oldPath, newPath, callback) {\n  return maybeCallback(callback, this, function() {\n    var oldItem = this._system.getItem(oldPath);\n    if (!oldItem) {\n      throw new FSError('ENOENT', oldPath);\n    }\n    var oldParent = this._system.getItem(path.dirname(oldPath));\n    var oldName = path.basename(oldPath);\n    var newItem = this._system.getItem(newPath);\n    var newParent = this._system.getItem(path.dirname(newPath));\n    var newName = path.basename(newPath);\n    if (newItem) {\n      // make sure they are the same type\n      if (oldItem instanceof File) {\n        if (newItem instanceof Directory) {\n          throw new FSError('EISDIR', newPath);\n        }\n      } else if (oldItem instanceof Directory) {\n        if (!(newItem instanceof Directory)) {\n          throw new FSError('ENOTDIR', newPath);\n        }\n        if (newItem.list().length > 0) {\n          throw new FSError('ENOTEMPTY', newPath);\n        }\n      }\n      newParent.removeItem(newName);\n    } else {\n      if (!newParent) {\n        throw new FSError('ENOENT', newPath);\n      }\n      if (!(newParent instanceof Directory)) {\n        throw new FSError('ENOTDIR', newPath);\n      }\n    }\n    oldParent.removeItem(oldName);\n    newParent.addItem(newName, oldItem);\n  });\n};\n\n\n/**\n * Read a directory.\n * @param {string} dirpath Path to directory.\n * @param {string} encoding The encoding ('utf-8' or 'buffer').\n * @param {function(Error, (Array.<string>|Array.<Buffer>)} callback Callback\n *     (optional) called with any error or array of items in the directory.\n * @return {Array.<string>|Array.<Buffer>} Array of items in directory (if sync).\n */\nBinding.prototype.readdir = function(dirpath, encoding, callback) {\n  if (encoding && typeof encoding !== 'string') {\n    callback = encoding;\n    encoding = 'utf-8';\n  }\n  return maybeCallback(callback, this, function() {\n    var dpath = dirpath;\n    var dir = this._system.getItem(dirpath);\n    while (dir instanceof SymbolicLink) {\n      dpath = path.resolve(path.dirname(dpath), dir.getPath());\n      dir = this._system.getItem(dpath);\n    }\n    if (!dir) {\n      throw new FSError('ENOENT', dirpath);\n    }\n    if (!(dir instanceof Directory)) {\n      throw new FSError('ENOTDIR', dirpath);\n    }\n    var list = dir.list();\n    if (encoding === 'buffer') {\n      list = list.map(function(item) {\n        return new Buffer(item);\n      });\n    }\n    return list;\n  });\n};\n\n\n/**\n * Create a directory.\n * @param {string} pathname Path to new directory.\n * @param {number} mode Permissions.\n * @param {function(Error)} callback Optional callback.\n */\nBinding.prototype.mkdir = function(pathname, mode, callback) {\n  maybeCallback(callback, this, function() {\n    var item = this._system.getItem(pathname);\n    if (item) {\n      throw new FSError('EEXIST', pathname);\n    }\n    var parent = this._system.getItem(path.dirname(pathname));\n    if (!parent) {\n      throw new FSError('ENOENT', pathname);\n    }\n    this.access(path.dirname(pathname), parseInt('0002', 8));\n    var dir = new Directory();\n    if (mode) {\n      dir.setMode(mode);\n    }\n    parent.addItem(path.basename(pathname), dir);\n  });\n};\n\n\n/**\n * Remove a directory.\n * @param {string} pathname Path to directory.\n * @param {function(Error)} callback Optional callback.\n */\nBinding.prototype.rmdir = function(pathname, callback) {\n  maybeCallback(callback, this, function() {\n    var item = this._system.getItem(pathname);\n    if (!item) {\n      throw new FSError('ENOENT', pathname);\n    }\n    if (!(item instanceof Directory)) {\n      throw new FSError('ENOTDIR', pathname);\n    }\n    if (item.list().length > 0) {\n      throw new FSError('ENOTEMPTY', pathname);\n    }\n    this.access(path.dirname(pathname), parseInt('0002', 8));\n    var parent = this._system.getItem(path.dirname(pathname));\n    parent.removeItem(path.basename(pathname));\n  });\n};\n\n\n/**\n * Truncate a file.\n * @param {number} fd File descriptor.\n * @param {number} len Number of bytes.\n * @param {function(Error)} callback Optional callback.\n */\nBinding.prototype.ftruncate = function(fd, len, callback) {\n  maybeCallback(callback, this, function() {\n    var descriptor = this._getDescriptorById(fd);\n    if (!descriptor.isWrite()) {\n      throw new FSError('EINVAL');\n    }\n    var file = descriptor.getItem();\n    if (!(file instanceof File)) {\n      throw new FSError('EINVAL');\n    }\n    var content = file.getContent();\n    var newContent = new Buffer(len);\n    content.copy(newContent);\n    file.setContent(newContent);\n  });\n};\n\n\n/**\n * Legacy support.\n * @param {number} fd File descriptor.\n * @param {number} len Number of bytes.\n * @param {function(Error)} callback Optional callback.\n */\nBinding.prototype.truncate = Binding.prototype.ftruncate;\n\n\n/**\n * Change user and group owner.\n * @param {string} pathname Path.\n * @param {number} uid User id.\n * @param {number} gid Group id.\n * @param {function(Error)} callback Optional callback.\n */\nBinding.prototype.chown = function(pathname, uid, gid, callback) {\n  maybeCallback(callback, this, function() {\n    var item = this._system.getItem(pathname);\n    if (!item) {\n      throw new FSError('ENOENT', pathname);\n    }\n    item.setUid(uid);\n    item.setGid(gid);\n  });\n};\n\n\n/**\n * Change user and group owner.\n * @param {number} fd File descriptor.\n * @param {number} uid User id.\n * @param {number} gid Group id.\n * @param {function(Error)} callback Optional callback.\n */\nBinding.prototype.fchown = function(fd, uid, gid, callback) {\n  maybeCallback(callback, this, function() {\n    var descriptor = this._getDescriptorById(fd);\n    var item = descriptor.getItem();\n    item.setUid(uid);\n    item.setGid(gid);\n  });\n};\n\n\n/**\n * Change permissions.\n * @param {string} pathname Path.\n * @param {number} mode Mode.\n * @param {function(Error)} callback Optional callback.\n */\nBinding.prototype.chmod = function(pathname, mode, callback) {\n  maybeCallback(callback, this, function() {\n    var item = this._system.getItem(pathname);\n    if (!item) {\n      throw new FSError('ENOENT', pathname);\n    }\n    item.setMode(mode);\n  });\n};\n\n\n/**\n * Change permissions.\n * @param {number} fd File descriptor.\n * @param {number} mode Mode.\n * @param {function(Error)} callback Optional callback.\n */\nBinding.prototype.fchmod = function(fd, mode, callback) {\n  maybeCallback(callback, this, function() {\n    var descriptor = this._getDescriptorById(fd);\n    var item = descriptor.getItem();\n    item.setMode(mode);\n  });\n};\n\n\n/**\n * Delete a named item.\n * @param {string} pathname Path to item.\n * @param {function(Error)} callback Optional callback.\n */\nBinding.prototype.unlink = function(pathname, callback) {\n  maybeCallback(callback, this, function() {\n    var item = this._system.getItem(pathname);\n    if (!item) {\n      throw new FSError('ENOENT', pathname);\n    }\n    if (item instanceof Directory) {\n      throw new FSError('EPERM', pathname);\n    }\n    var parent = this._system.getItem(path.dirname(pathname));\n    parent.removeItem(path.basename(pathname));\n  });\n};\n\n\n/**\n * Update timestamps.\n * @param {string} pathname Path to item.\n * @param {number} atime Access time (in seconds).\n * @param {number} mtime Modification time (in seconds).\n * @param {function(Error)} callback Optional callback.\n */\nBinding.prototype.utimes = function(pathname, atime, mtime, callback) {\n  maybeCallback(callback, this, function() {\n    var item = this._system.getItem(pathname);\n    if (!item) {\n      throw new FSError('ENOENT', pathname);\n    }\n    item.setATime(new Date(atime * 1000));\n    item.setMTime(new Date(mtime * 1000));\n  });\n};\n\n\n/**\n * Update timestamps.\n * @param {number} fd File descriptor.\n * @param {number} atime Access time (in seconds).\n * @param {number} mtime Modification time (in seconds).\n * @param {function(Error)} callback Optional callback.\n */\nBinding.prototype.futimes = function(fd, atime, mtime, callback) {\n  maybeCallback(callback, this, function() {\n    var descriptor = this._getDescriptorById(fd);\n    var item = descriptor.getItem();\n    item.setATime(new Date(atime * 1000));\n    item.setMTime(new Date(mtime * 1000));\n  });\n};\n\n\n/**\n * Synchronize in-core state with storage device.\n * @param {number} fd File descriptor.\n * @param {function(Error)} callback Optional callback.\n */\nBinding.prototype.fsync = function(fd, callback) {\n  maybeCallback(callback, this, function() {\n    this._getDescriptorById(fd);\n  });\n};\n\n\n/**\n * Synchronize in-core metadata state with storage device.\n * @param {number} fd File descriptor.\n * @param {function(Error)} callback Optional callback.\n */\nBinding.prototype.fdatasync = function(fd, callback) {\n  maybeCallback(callback, this, function() {\n    this._getDescriptorById(fd);\n  });\n};\n\n\n/**\n * Create a hard link.\n * @param {string} srcPath The existing file.\n * @param {string} destPath The new link to create.\n * @param {function(Error)} callback Optional callback.\n */\nBinding.prototype.link = function(srcPath, destPath, callback) {\n  maybeCallback(callback, this, function() {\n    var item = this._system.getItem(srcPath);\n    if (!item) {\n      throw new FSError('ENOENT', srcPath);\n    }\n    if (item instanceof Directory) {\n      throw new FSError('EPERM', srcPath);\n    }\n    if (this._system.getItem(destPath)) {\n      throw new FSError('EEXIST', destPath);\n    }\n    var parent = this._system.getItem(path.dirname(destPath));\n    if (!parent) {\n      throw new FSError('ENOENT', destPath);\n    }\n    if (!(parent instanceof Directory)) {\n      throw new FSError('ENOTDIR', destPath);\n    }\n    parent.addItem(path.basename(destPath), item);\n  });\n};\n\n\n/**\n * Create a symbolic link.\n * @param {string} srcPath Path from link to the source file.\n * @param {string} destPath Path for the generated link.\n * @param {string} type Ignored (used for Windows only).\n * @param {function(Error)} callback Optional callback.\n */\nBinding.prototype.symlink = function(srcPath, destPath, type, callback) {\n  maybeCallback(callback, this, function() {\n    if (this._system.getItem(destPath)) {\n      throw new FSError('EEXIST', destPath);\n    }\n    var parent = this._system.getItem(path.dirname(destPath));\n    if (!parent) {\n      throw new FSError('ENOENT', destPath);\n    }\n    if (!(parent instanceof Directory)) {\n      throw new FSError('ENOTDIR', destPath);\n    }\n    var link = new SymbolicLink();\n    link.setPath(srcPath);\n    parent.addItem(path.basename(destPath), link);\n  });\n};\n\n\n/**\n * Read the contents of a symbolic link.\n * @param {string} pathname Path to symbolic link.\n * @param {string} encoding The encoding ('utf-8' or 'buffer').\n * @param {function(Error, (string|Buffer))} callback Optional callback.\n * @return {string|Buffer} Symbolic link contents (path to source).\n */\nBinding.prototype.readlink = function(pathname, encoding, callback) {\n  if (encoding && typeof encoding !== 'string') {\n    callback = encoding;\n    encoding = 'utf-8';\n  }\n  return maybeCallback(callback, this, function() {\n    var link = this._system.getItem(pathname);\n    if (!(link instanceof SymbolicLink)) {\n      throw new FSError('EINVAL', pathname);\n    }\n    var linkPath = link.getPath();\n    if (encoding === 'buffer') {\n      linkPath = new Buffer(linkPath);\n    }\n    return linkPath;\n  });\n};\n\n\n/**\n * Stat an item.\n * @param {string} filepath Path.\n * @param {function(Error, Stats)|Float64Array} callback Callback (optional). In Node 7.7.0+ this will be a Float64Array\n * that should be filled with stat values.\n * @return {Stats|undefined} Stats or undefined (if sync).\n */\nBinding.prototype.lstat = function(filepath, callback) {\n  return maybeCallback(callback, this, function() {\n    var item = this._system.getItem(filepath);\n    if (!item) {\n      throw new FSError('ENOENT', filepath);\n    }\n    var stats = item.getStats();\n\n    // In Node 7.7.0+, binding.stat accepts a Float64Array as the second argument,\n    // which should be filled with stat values.\n    // In prior versions of Node, binding.stat simply returns a Stats instance.\n    if (callback instanceof Float64Array) {\n      fillStatsArray(stats, callback);\n    } else {\n      return new Stats(item.getStats());\n    }\n  });\n};\n\n/**\n * Tests user permissions.\n * @param {string} filepath Path.\n * @param {number} mode Mode.\n * @param {function(Error)} callback Callback (optional).\n */\nBinding.prototype.access = function(filepath, mode, callback) {\n  maybeCallback(callback, this, function() {\n    var item = this._system.getItem(filepath);\n    if (!item) {\n      throw new FSError('ENOENT', filepath);\n    }\n    if (mode && process.getuid && process.getgid) {\n      var itemMode = item.getMode();\n      if (item.getUid() === process.getuid()) {\n        if ((itemMode & (mode * 64)) !== mode * 64) {\n          throw new FSError('EACCES', filepath);\n        }\n      } else if (item.getGid() === process.getgid()) {\n        if ((itemMode & (mode * 8)) !== mode * 8) {\n          throw new FSError('EACCES', filepath);\n        }\n      } else {\n        if ((itemMode & mode) !== mode) {\n          throw new FSError('EACCES', filepath);\n        }\n      }\n    }\n  });\n};\n\n/**\n * Not yet implemented.\n * @type {function()}\n */\nBinding.prototype.StatWatcher = notImplemented;\n\n\n/**\n * Export the binding constructor.\n * @type {function()}\n */\nexports = module.exports = Binding;\n","/home/travis/build/npmtest/node-npmtest-mock-fs/node_modules/mock-fs/lib/file.js":"'use strict';\n\nvar util = require('util');\n\nvar Item = require('./item');\n\nvar EMPTY = new Buffer(0);\nvar constants = require('constants');\n\n\n/**\n * A directory.\n * @constructor\n */\nfunction File() {\n  Item.call(this);\n\n  /**\n   * File content.\n   * @type {Buffer}\n   */\n  this._content = EMPTY;\n\n}\nutil.inherits(File, Item);\n\n\n/**\n * Get the file contents.\n * @return {Buffer} File contents.\n */\nFile.prototype.getContent = function() {\n  this.setATime(new Date());\n  return this._content;\n};\n\n\n/**\n * Set the file contents.\n * @param {string|Buffer} content File contents.\n */\nFile.prototype.setContent = function(content) {\n  if (typeof content === 'string') {\n    content = new Buffer(content);\n  } else if (!Buffer.isBuffer(content)) {\n    throw new Error('File content must be a string or buffer');\n  }\n  this._content = content;\n  var now = Date.now();\n  this.setCTime(new Date(now));\n  this.setMTime(new Date(now));\n};\n\n\n/**\n * Get file stats.\n * @return {Object} Stats properties.\n */\nFile.prototype.getStats = function() {\n  var size = this._content.length;\n  var stats = Item.prototype.getStats.call(this);\n  stats.mode = this.getMode() | constants.S_IFREG;\n  stats.size = size;\n  stats.blocks = Math.ceil(size / 512);\n  return stats;\n};\n\n\n/**\n * Export the constructor.\n * @type {function()}\n */\nexports = module.exports = File;\n","/home/travis/build/npmtest/node-npmtest-mock-fs/node_modules/mock-fs/lib/item.js":"'use strict';\n\nvar counter = 0;\n\n\n/**\n * Permissions.\n * @enum {number}\n */\nvar permissions = {\n  USER_READ: 256, // 0400\n  USER_WRITE: 128, // 0200\n  USER_EXEC: 64, // 0100\n  GROUP_READ: 32, // 0040\n  GROUP_WRITE: 16, // 0020\n  GROUP_EXEC: 8, // 0010\n  OTHER_READ: 4, // 0004\n  OTHER_WRITE: 2, // 0002\n  OTHER_EXEC: 1 // 0001\n};\n\nfunction getUid() {\n  return process.getuid && process.getuid();\n}\n\nfunction getGid() {\n  return process.getgid && process.getgid();\n}\n\n\n/**\n * A filesystem item.\n * @constructor\n */\nfunction Item() {\n\n  var now = Date.now();\n\n  /**\n   * Access time.\n   * @type {Date}\n   */\n  this._atime = new Date(now);\n\n  /**\n   * Change time.\n   * @type {Date}\n   */\n  this._ctime = new Date(now);\n\n  /**\n   * Birth time.\n   * @type {Date}\n   */\n  this._birthtime = new Date(now);\n\n  /**\n   * Modification time.\n   * @type {Date}\n   */\n  this._mtime = new Date(now);\n\n  /**\n   * Permissions.\n   */\n  this._mode = 438; // 0666\n\n  /**\n   * User id.\n   * @type {number}\n   */\n  this._uid = getUid();\n\n  /**\n   * Group id.\n   * @type {number}\n   */\n  this._gid = getGid();\n\n  /**\n   * Item number.\n   * @type {number}\n   */\n  this._id = ++counter;\n\n  /**\n   * Number of links to this item.\n   */\n  this.links = 0;\n\n}\n\n\n/**\n * Determine if the current user has read permission.\n * @return {boolean} The current user can read.\n */\nItem.prototype.canRead = function() {\n  var uid = getUid();\n  var gid = getGid();\n  var can = false;\n  if (uid === 0) {\n    can = true;\n  } else if (uid === this._uid) {\n    can = (permissions.USER_READ & this._mode) === permissions.USER_READ;\n  } else if (gid === this._gid) {\n    can = (permissions.GROUP_READ & this._mode) === permissions.GROUP_READ;\n  } else {\n    can = (permissions.OTHER_READ & this._mode) === permissions.OTHER_READ;\n  }\n  return can;\n};\n\n\n/**\n * Determine if the current user has write permission.\n * @return {boolean} The current user can write.\n */\nItem.prototype.canWrite = function() {\n  var uid = getUid();\n  var gid = getGid();\n  var can = false;\n  if (uid === 0) {\n    can = true;\n  } else if (uid === this._uid) {\n    can = (permissions.USER_WRITE & this._mode) === permissions.USER_WRITE;\n  } else if (gid === this._gid) {\n    can = (permissions.GROUP_WRITE & this._mode) === permissions.GROUP_WRITE;\n  } else {\n    can = (permissions.OTHER_WRITE & this._mode) === permissions.OTHER_WRITE;\n  }\n  return can;\n};\n\n\n/**\n * Determine if the current user has execute permission.\n * @return {boolean} The current user can execute.\n */\nItem.prototype.canExecute = function() {\n  var uid = getUid();\n  var gid = getGid();\n  var can = false;\n  if (uid === 0) {\n    can = true;\n  } else if (uid === this._uid) {\n    can = (permissions.USER_EXEC & this._mode) === permissions.USER_EXEC;\n  } else if (gid === this._gid) {\n    can = (permissions.GROUP_EXEC & this._mode) === permissions.GROUP_EXEC;\n  } else {\n    can = (permissions.OTHER_EXEC & this._mode) === permissions.OTHER_EXEC;\n  }\n  return can;\n};\n\n\n/**\n * Get access time.\n * @return {Date} Access time.\n */\nItem.prototype.getATime = function() {\n  return this._atime;\n};\n\n\n/**\n * Set access time.\n * @param {Date} atime Access time.\n */\nItem.prototype.setATime = function(atime) {\n  this._atime = atime;\n};\n\n\n/**\n * Get change time.\n * @return {Date} Change time.\n */\nItem.prototype.getCTime = function() {\n  return this._ctime;\n};\n\n\n/**\n * Set change time.\n * @param {Date} ctime Change time.\n */\nItem.prototype.setCTime = function(ctime) {\n  this._ctime = ctime;\n};\n\n\n/**\n * Get birth time.\n * @return {Date} Birth time.\n */\nItem.prototype.getBirthtime = function() {\n  return this._birthtime;\n};\n\n\n/**\n * Set change time.\n * @param {Date} birthtime Birth time.\n */\nItem.prototype.setBirthtime = function(birthtime) {\n  this._birthtime = birthtime;\n};\n\n\n/**\n * Get modification time.\n * @return {Date} Modification time.\n */\nItem.prototype.getMTime = function() {\n  return this._mtime;\n};\n\n\n/**\n * Set modification time.\n * @param {Date} mtime Modification time.\n */\nItem.prototype.setMTime = function(mtime) {\n  this._mtime = mtime;\n};\n\n\n/**\n * Get mode (permission only, e.g 0666).\n * @return {number} Mode.\n */\nItem.prototype.getMode = function() {\n  return this._mode;\n};\n\n\n/**\n * Set mode (permission only, e.g 0666).\n * @param {Date} mode Mode.\n */\nItem.prototype.setMode = function(mode) {\n  this.setCTime(new Date());\n  this._mode = mode;\n};\n\n\n/**\n * Get user id.\n * @return {number} User id.\n */\nItem.prototype.getUid = function() {\n  return this._uid;\n};\n\n\n/**\n * Set user id.\n * @param {number} uid User id.\n */\nItem.prototype.setUid = function(uid) {\n  this.setCTime(new Date());\n  this._uid = uid;\n};\n\n\n/**\n * Get group id.\n * @return {number} Group id.\n */\nItem.prototype.getGid = function() {\n  return this._gid;\n};\n\n\n/**\n * Set group id.\n * @param {number} gid Group id.\n */\nItem.prototype.setGid = function(gid) {\n  this.setCTime(new Date());\n  this._gid = gid;\n};\n\n\n/**\n * Get item stats.\n * @return {Object} Stats properties.\n */\nItem.prototype.getStats = function() {\n  return {\n    dev: 8675309,\n    nlink: this.links,\n    uid: this.getUid(),\n    gid: this.getGid(),\n    rdev: 0,\n    blksize: 4096,\n    ino: this._id,\n    atime: this.getATime(),\n    mtime: this.getMTime(),\n    ctime: this.getCTime(),\n    birthtime: this.getBirthtime()\n  };\n};\n\n\n/**\n * Get the item's string representation.\n * @return {string} String representation.\n */\nItem.prototype.toString = function() {\n  return '[' + this.constructor.name + ']';\n};\n\n\n/**\n * Export the constructor.\n * @type {function()}\n */\nexports = module.exports = Item;\n","/home/travis/build/npmtest/node-npmtest-mock-fs/node_modules/mock-fs/lib/descriptor.js":"'use strict';\n\nvar constants = require('constants');\n\n\n/**\n * Create a new file descriptor.\n * @param {number} flags Flags.\n * @constructor\n */\nfunction FileDescriptor(flags) {\n\n  /**\n   * Flags.\n   * @type {number}\n   */\n  this._flags = flags;\n\n  /**\n   * File system item.\n   * @type {Item}\n   */\n  this._item = null;\n\n  /**\n   * Current file position.\n   * @type {number}\n   */\n  this._position = 0;\n\n}\n\n\n/**\n * Set the item.\n * @param {Item} item File system item.\n */\nFileDescriptor.prototype.setItem = function(item) {\n  this._item = item;\n};\n\n\n/**\n * Get the item.\n * @return {Item} File system item.\n */\nFileDescriptor.prototype.getItem = function() {\n  return this._item;\n};\n\n\n/**\n * Get the current file position.\n * @return {number} File position.\n */\nFileDescriptor.prototype.getPosition = function() {\n  return this._position;\n};\n\n\n/**\n * Set the current file position.\n * @param {number} position File position.\n */\nFileDescriptor.prototype.setPosition = function(position) {\n  this._position = position;\n};\n\n\n/**\n * Check if file opened for appending.\n * @return {boolean} Opened for appending.\n */\nFileDescriptor.prototype.isAppend = function() {\n  return ((this._flags & constants.O_APPEND) === constants.O_APPEND);\n};\n\n\n/**\n * Check if file opened for creation.\n * @return {boolean} Opened for creation.\n */\nFileDescriptor.prototype.isCreate = function() {\n  return ((this._flags & constants.O_CREAT) === constants.O_CREAT);\n};\n\n\n/**\n * Check if file opened for reading.\n * @return {boolean} Opened for reading.\n */\nFileDescriptor.prototype.isRead = function() {\n  // special treatment because O_RDONLY is 0\n  return (this._flags === constants.O_RDONLY) ||\n      (this._flags === (constants.O_RDONLY | constants.O_SYNC)) ||\n      ((this._flags & constants.O_RDWR) === constants.O_RDWR);\n};\n\n\n/**\n * Check if file opened for writing.\n * @return {boolean} Opened for writing.\n */\nFileDescriptor.prototype.isWrite = function() {\n  return ((this._flags & constants.O_WRONLY) === constants.O_WRONLY) ||\n      ((this._flags & constants.O_RDWR) === constants.O_RDWR);\n};\n\n\n/**\n * Check if file opened for truncating.\n * @return {boolean} Opened for truncating.\n */\nFileDescriptor.prototype.isTruncate = function() {\n  return (this._flags & constants.O_TRUNC) === constants.O_TRUNC;\n};\n\n\n/**\n * Check if file opened with exclusive flag.\n * @return {boolean} Opened with exclusive.\n */\nFileDescriptor.prototype.isExclusive = function() {\n  return ((this._flags & constants.O_EXCL) === constants.O_EXCL);\n};\n\n\n/**\n * Export the constructor.\n * @type {function()}\n */\nexports = module.exports = FileDescriptor;\n","/home/travis/build/npmtest/node-npmtest-mock-fs/node_modules/mock-fs/lib/directory.js":"'use strict';\n\nvar util = require('util');\n\nvar Item = require('./item');\n\nvar constants = require('constants');\n\n\n/**\n * A directory.\n * @constructor\n */\nfunction Directory() {\n  Item.call(this);\n\n  /**\n   * Items in this directory.\n   * @type {Object.<string, Item>}\n   */\n  this._items = {};\n\n  /**\n   * Permissions.\n   */\n  this._mode = 511; // 0777\n\n}\nutil.inherits(Directory, Item);\n\n\n/**\n * Add an item to the directory.\n * @param {string} name The name to give the item.\n * @param {Item} item The item to add.\n * @return {Item} The added item.\n */\nDirectory.prototype.addItem = function(name, item) {\n  if (this._items.hasOwnProperty(name)) {\n    throw new Error('Item with the same name already exists: ' + name);\n  }\n  this._items[name] = item;\n  ++item.links;\n  if (item instanceof Directory) {\n    // for '.' entry\n    ++item.links;\n    // for subdirectory\n    ++this.links;\n  }\n  this.setMTime(new Date());\n  return item;\n};\n\n\n/**\n * Get a named item.\n * @param {string} name Item name.\n * @return {Item} The named item (or null if none).\n */\nDirectory.prototype.getItem = function(name) {\n  var item = null;\n  if (this._items.hasOwnProperty(name)) {\n    item = this._items[name];\n  }\n  return item;\n};\n\n\n/**\n * Remove an item.\n * @param {string} name Name of item to remove.\n * @return {Item} The orphan item.\n */\nDirectory.prototype.removeItem = function(name) {\n  if (!this._items.hasOwnProperty(name)) {\n    throw new Error('Item does not exist in directory: ' + name);\n  }\n  var item = this._items[name];\n  delete this._items[name];\n  --item.links;\n  if (item instanceof Directory) {\n    // for '.' entry\n    --item.links;\n    // for subdirectory\n    --this.links;\n  }\n  this.setMTime(new Date());\n  return item;\n};\n\n\n/**\n * Get list of item names in this directory.\n * @return {Array.<string>} Item names.\n */\nDirectory.prototype.list = function() {\n  return Object.keys(this._items).sort();\n};\n\n\n/**\n * Get directory stats.\n * @return {Object} Stats properties.\n */\nDirectory.prototype.getStats = function() {\n  var stats = Item.prototype.getStats.call(this);\n  stats.mode = this.getMode() | constants.S_IFDIR;\n  stats.size = 1;\n  stats.blocks = 1;\n  return stats;\n};\n\n\n/**\n * Export the constructor.\n * @type {function()}\n */\nexports = module.exports = Directory;\n","/home/travis/build/npmtest/node-npmtest-mock-fs/node_modules/mock-fs/lib/symlink.js":"'use strict';\n\nvar util = require('util');\n\nvar Item = require('./item');\n\nvar constants = require('constants');\n\n\n/**\n * A directory.\n * @constructor\n */\nfunction SymbolicLink() {\n  Item.call(this);\n\n  /**\n   * Relative path to source.\n   * @type {string}\n   */\n  this._path = undefined;\n\n}\nutil.inherits(SymbolicLink, Item);\n\n\n/**\n * Set the path to the source.\n * @param {string} pathname Path to source.\n */\nSymbolicLink.prototype.setPath = function(pathname) {\n  this._path = pathname;\n};\n\n\n/**\n * Get the path to the source.\n * @return {string} Path to source.\n */\nSymbolicLink.prototype.getPath = function() {\n  return this._path;\n};\n\n\n/**\n * Get symbolic link stats.\n * @return {Object} Stats properties.\n */\nSymbolicLink.prototype.getStats = function() {\n  var size = this._path.length;\n  var stats = Item.prototype.getStats.call(this);\n  stats.mode = this.getMode() | constants.S_IFLNK;\n  stats.size = size;\n  stats.blocks = Math.ceil(size / 512);\n  return stats;\n};\n\n\n/**\n * Export the constructor.\n * @type {function()}\n */\nexports = module.exports = SymbolicLink;\n","/home/travis/build/npmtest/node-npmtest-mock-fs/node_modules/mock-fs/lib/error.js":"'use strict';\n\n\n/**\n * Error codes from libuv.\n * @enum {number}\n */\nvar codes = {\n  UNKNOWN: {\n    errno: -1,\n    message: 'unknown error'\n  },\n  OK: {\n    errno: 0,\n    message: 'success'\n  },\n  EOF: {\n    errno: 1,\n    message: 'end of file'\n  },\n  EADDRINFO: {\n    errno: 2,\n    message: 'getaddrinfo error'\n  },\n  EACCES: {\n    errno: 3,\n    message: 'permission denied'\n  },\n  EAGAIN: {\n    errno: 4,\n    message: 'resource temporarily unavailable'\n  },\n  EADDRINUSE: {\n    errno: 5,\n    message: 'address already in use'\n  },\n  EADDRNOTAVAIL: {\n    errno: 6,\n    message: 'address not available'\n  },\n  EAFNOSUPPORT: {\n    errno: 7,\n    message: 'address family not supported'\n  },\n  EALREADY: {\n    errno: 8,\n    message: 'connection already in progress'\n  },\n  EBADF: {\n    errno: 9,\n    message: 'bad file descriptor'\n  },\n  EBUSY: {\n    errno: 10,\n    message: 'resource busy or locked'\n  },\n  ECONNABORTED: {\n    errno: 11,\n    message: 'software caused connection abort'\n  },\n  ECONNREFUSED: {\n    errno: 12,\n    message: 'connection refused'\n  },\n  ECONNRESET: {\n    errno: 13,\n    message: 'connection reset by peer'\n  },\n  EDESTADDRREQ: {\n    errno: 14,\n    message: 'destination address required'\n  },\n  EFAULT: {\n    errno: 15,\n    message: 'bad address in system call argument'\n  },\n  EHOSTUNREACH: {\n    errno: 16,\n    message: 'host is unreachable'\n  },\n  EINTR: {\n    errno: 17,\n    message: 'interrupted system call'\n  },\n  EINVAL: {\n    errno: 18,\n    message: 'invalid argument'\n  },\n  EISCONN: {\n    errno: 19,\n    message: 'socket is already connected'\n  },\n  EMFILE: {\n    errno: 20,\n    message: 'too many open files'\n  },\n  EMSGSIZE: {\n    errno: 21,\n    message: 'message too long'\n  },\n  ENETDOWN: {\n    errno: 22,\n    message: 'network is down'\n  },\n  ENETUNREACH: {\n    errno: 23,\n    message: 'network is unreachable'\n  },\n  ENFILE: {\n    errno: 24,\n    message: 'file table overflow'\n  },\n  ENOBUFS: {\n    errno: 25,\n    message: 'no buffer space available'\n  },\n  ENOMEM: {\n    errno: 26,\n    message: 'not enough memory'\n  },\n  ENOTDIR: {\n    errno: 27,\n    message: 'not a directory'\n  },\n  EISDIR: {\n    errno: 28,\n    message: 'illegal operation on a directory'\n  },\n  ENONET: {\n    errno: 29,\n    message: 'machine is not on the network'\n  },\n  ENOTCONN: {\n    errno: 31,\n    message: 'socket is not connected'\n  },\n  ENOTSOCK: {\n    errno: 32,\n    message: 'socket operation on non-socket'\n  },\n  ENOTSUP: {\n    errno: 33,\n    message: 'operation not supported on socket'\n  },\n  ENOENT: {\n    errno: 34,\n    message: 'no such file or directory'\n  },\n  ENOSYS: {\n    errno: 35,\n    message: 'function not implemented'\n  },\n  EPIPE: {\n    errno: 36,\n    message: 'broken pipe'\n  },\n  EPROTO: {\n    errno: 37,\n    message: 'protocol error'\n  },\n  EPROTONOSUPPORT: {\n    errno: 38,\n    message: 'protocol not supported'\n  },\n  EPROTOTYPE: {\n    errno: 39,\n    message: 'protocol wrong type for socket'\n  },\n  ETIMEDOUT: {\n    errno: 40,\n    message: 'connection timed out'\n  },\n  ECHARSET: {\n    errno: 41,\n    message: 'invalid Unicode character'\n  },\n  EAIFAMNOSUPPORT: {\n    errno: 42,\n    message: 'address family for hostname not supported'\n  },\n  EAISERVICE: {\n    errno: 44,\n    message: 'servname not supported for ai_socktype'\n  },\n  EAISOCKTYPE: {\n    errno: 45,\n    message: 'ai_socktype not supported'\n  },\n  ESHUTDOWN: {\n    errno: 46,\n    message: 'cannot send after transport endpoint shutdown'\n  },\n  EEXIST: {\n    errno: 47,\n    message: 'file already exists'\n  },\n  ESRCH: {\n    errno: 48,\n    message: 'no such process'\n  },\n  ENAMETOOLONG: {\n    errno: 49,\n    message: 'name too long'\n  },\n  EPERM: {\n    errno: 50,\n    message: 'operation not permitted'\n  },\n  ELOOP: {\n    errno: 51,\n    message: 'too many symbolic links encountered'\n  },\n  EXDEV: {\n    errno: 52,\n    message: 'cross-device link not permitted'\n  },\n  ENOTEMPTY: {\n    errno: 53,\n    message: 'directory not empty'\n  },\n  ENOSPC: {\n    errno: 54,\n    message: 'no space left on device'\n  },\n  EIO: {\n    errno: 55,\n    message: 'i/o error'\n  },\n  EROFS: {\n    errno: 56,\n    message: 'read-only file system'\n  },\n  ENODEV: {\n    errno: 57,\n    message: 'no such device'\n  },\n  ESPIPE: {\n    errno: 58,\n    message: 'invalid seek'\n  },\n  ECANCELED: {\n    errno: 59,\n    message: 'peration canceled'\n  }\n};\n\n\n/**\n * Create an error.\n * @param {string} code Error code.\n * @param {string} path Path (optional).\n * @constructor\n */\nfunction FSError(code, path) {\n  if (!codes.hasOwnProperty(code)) {\n    throw new Error('Programmer error, invalid error code: ' + code);\n  }\n  Error.call(this);\n  var details = codes[code];\n  var message = code + ', ' + details.message;\n  if (path) {\n    message += ' \\'' + path + '\\'';\n  }\n  this.message = message;\n  this.code = code;\n  this.errno = details.errno;\n  Error.captureStackTrace(this, FSError);\n}\nFSError.prototype = new Error();\n\n\n/**\n * Error constructor.\n */\nexports = module.exports = FSError;\n","/home/travis/build/npmtest/node-npmtest-mock-fs/node_modules/mock-fs/lib/filesystem.js":"'use strict';\n\nvar os = require('os');\nvar path = require('path');\n\nvar Directory = require('./directory');\nvar File = require('./file');\nvar FSError = require('./error');\nvar SymbolicLink = require('./symlink');\n\n\nvar isWindows = process.platform === 'win32';\n\nfunction getPathParts(filepath) {\n  var parts = path._makeLong(path.resolve(filepath)).split(path.sep);\n  parts.shift();\n  if (isWindows) {\n    // parts currently looks like ['', '?', 'c:', ...]\n    parts.shift();\n    var q = parts.shift(); // should be '?'\n    var base = '\\\\\\\\' + q + '\\\\' + parts.shift().toLowerCase();\n    parts.unshift(base);\n  }\n  if (parts[parts.length - 1] === '') {\n    parts.pop();\n  }\n  return parts;\n}\n\n\n/**\n * Create a new file system.\n * @param {Object} options Any filesystem options.\n * @param {boolean} options.createCwd Create a directory for `process.cwd()`\n *     (defaults to `true`).\n * @param {boolean} options.createTmp Create a directory for `os.tmpdir()`\n *     (defaults to `true`).\n * @constructor\n */\nfunction FileSystem(options) {\n  options = options || {};\n\n  var createCwd = 'createCwd' in options ? options.createCwd : true;\n  var createTmp = 'createTmp' in options ? options.createTmp : true;\n\n  var root = new Directory();\n\n  // populate with default directories\n  var defaults = [];\n  if (createCwd) {\n    defaults.push(process.cwd());\n  }\n\n  if (createTmp) {\n    defaults.push(os.tmpdir && os.tmpdir() || os.tmpDir());\n  }\n\n  defaults.forEach(function(dir) {\n    var parts = getPathParts(dir);\n    var directory = root;\n    var i, ii, name, candidate;\n    for (i = 0, ii = parts.length; i < ii; ++i) {\n      name = parts[i];\n      candidate = directory.getItem(name);\n      if (!candidate) {\n        directory = directory.addItem(name, new Directory());\n      } else if (candidate instanceof Directory) {\n        directory = candidate;\n      } else {\n        throw new Error('Failed to create directory: ' + dir);\n      }\n    }\n  });\n\n  /**\n   * Root directory.\n   * @type {Directory}\n   */\n  this._root = root;\n\n}\n\n\n/**\n * Get the root directory.\n * @return {Directory} The root directory.\n */\nFileSystem.prototype.getRoot = function() {\n  return this._root;\n};\n\n\n/**\n * Get a file system item.\n * @param {string} filepath Path to item.\n * @return {Item} The item (or null if not found).\n */\nFileSystem.prototype.getItem = function(filepath) {\n  var parts = getPathParts(filepath);\n  var currentParts = getPathParts(process.cwd());\n  var item = this._root;\n  var itemPath = '/';\n  var name;\n  for (var i = 0, ii = parts.length; i < ii; ++i) {\n    name = parts[i];\n    while (item instanceof SymbolicLink) {\n      // Symbolic link being traversed as a directory --- If link targets\n      // another symbolic link, resolve target's path relative to the original\n      // link's target, otherwise relative to the current item.\n      itemPath = path.resolve(path.dirname(itemPath), item.getPath());\n      item = this.getItem(itemPath);\n    }\n    if (item) {\n      if (item instanceof Directory && name !== currentParts[i]) {\n        // make sure traversal is allowed\n        if (!item.canExecute()) {\n          throw new FSError('EACCES', filepath);\n        }\n      }\n      item = item.getItem(name);\n    }\n    if (!item) {\n      break;\n    }\n    itemPath = path.resolve(itemPath, name);\n  }\n  return item;\n};\n\n\n/**\n * Populate a directory with an item.\n * @param {Directory} directory The directory to populate.\n * @param {string} name The name of the item.\n * @param {string|Buffer|function|Object} obj Instructions for creating the\n *     item.\n */\nfunction populate(directory, name, obj) {\n  var item;\n  if (typeof obj === 'string' || Buffer.isBuffer(obj)) {\n    // contents for a file\n    item = new File();\n    item.setContent(obj);\n  } else if (typeof obj === 'function') {\n    // item factory\n    item = obj();\n  } else {\n    // directory with more to populate\n    item = new Directory();\n    for (var key in obj) {\n      populate(item, key, obj[key]);\n    }\n  }\n  /**\n   * Special exception for redundant adding of empty directories.\n   */\n  if (item instanceof Directory &&\n      item.list().length === 0 &&\n      directory.getItem(name) instanceof Directory) {\n    // pass\n  } else {\n    directory.addItem(name, item);\n  }\n}\n\n\n/**\n * Configure a mock file system.\n * @param {Object} paths Config object.\n * @param {Object} options Any filesystem options.\n * @param {boolean} options.createCwd Create a directory for `process.cwd()`\n *     (defaults to `true`).\n * @param {boolean} options.createTmp Create a directory for `os.tmpdir()`\n *     (defaults to `true`).\n * @return {FileSystem} Mock file system.\n */\nFileSystem.create = function(paths, options) {\n  var system = new FileSystem(options);\n\n  for (var filepath in paths) {\n    var parts = getPathParts(filepath);\n    var directory = system._root;\n    var i, ii, name, candidate;\n    for (i = 0, ii = parts.length - 1; i < ii; ++i) {\n      name = parts[i];\n      candidate = directory.getItem(name);\n      if (!candidate) {\n        directory = directory.addItem(name, new Directory());\n      } else if (candidate instanceof Directory) {\n        directory = candidate;\n      } else {\n        throw new Error('Failed to create directory: ' + filepath);\n      }\n    }\n    populate(directory, parts[i], paths[filepath]);\n  }\n\n  return system;\n};\n\n\n/**\n * Generate a factory for new files.\n * @param {Object} config File config.\n * @return {function():File} Factory that creates a new file.\n */\nFileSystem.file = function(config) {\n  config = config || {};\n  return function() {\n    var file = new File();\n    if (config.hasOwnProperty('content')) {\n      file.setContent(config.content);\n    }\n    if (config.hasOwnProperty('mode')) {\n      file.setMode(config.mode);\n    } else {\n      file.setMode(438); // 0666\n    }\n    if (config.hasOwnProperty('uid')) {\n      file.setUid(config.uid);\n    }\n    if (config.hasOwnProperty('gid')) {\n      file.setGid(config.gid);\n    }\n    if (config.hasOwnProperty('atime')) {\n      file.setATime(config.atime);\n    }\n    if (config.hasOwnProperty('ctime')) {\n      file.setCTime(config.ctime);\n    }\n    if (config.hasOwnProperty('mtime')) {\n      file.setMTime(config.mtime);\n    }\n    if (config.hasOwnProperty('birthtime')) {\n      file.setBirthtime(config.birthtime);\n    }\n    return file;\n  };\n};\n\n\n/**\n * Generate a factory for new symbolic links.\n * @param {Object} config File config.\n * @return {function():File} Factory that creates a new symbolic link.\n */\nFileSystem.symlink = function(config) {\n  config = config || {};\n  return function() {\n    var link = new SymbolicLink();\n    if (config.hasOwnProperty('mode')) {\n      link.setMode(config.mode);\n    } else {\n      link.setMode(438); // 0666\n    }\n    if (config.hasOwnProperty('uid')) {\n      link.setUid(config.uid);\n    }\n    if (config.hasOwnProperty('gid')) {\n      link.setGid(config.gid);\n    }\n    if (config.hasOwnProperty('path')) {\n      link.setPath(config.path);\n    } else {\n      throw new Error('Missing \"path\" property');\n    }\n    if (config.hasOwnProperty('atime')) {\n      link.setATime(config.atime);\n    }\n    if (config.hasOwnProperty('ctime')) {\n      link.setCTime(config.ctime);\n    }\n    if (config.hasOwnProperty('mtime')) {\n      link.setMTime(config.mtime);\n    }\n    if (config.hasOwnProperty('birthtime')) {\n      link.setBirthtime(config.birthtime);\n    }\n    return link;\n  };\n};\n\n\n/**\n * Generate a factory for new directories.\n * @param {Object} config File config.\n * @return {function():Directory} Factory that creates a new directory.\n */\nFileSystem.directory = function(config) {\n  config = config || {};\n  return function() {\n    var dir = new Directory();\n    if (config.hasOwnProperty('mode')) {\n      dir.setMode(config.mode);\n    }\n    if (config.hasOwnProperty('uid')) {\n      dir.setUid(config.uid);\n    }\n    if (config.hasOwnProperty('gid')) {\n      dir.setGid(config.gid);\n    }\n    if (config.hasOwnProperty('items')) {\n      for (var name in config.items) {\n        populate(dir, name, config.items[name]);\n      }\n    }\n    if (config.hasOwnProperty('atime')) {\n      dir.setATime(config.atime);\n    }\n    if (config.hasOwnProperty('ctime')) {\n      dir.setCTime(config.ctime);\n    }\n    if (config.hasOwnProperty('mtime')) {\n      dir.setMTime(config.mtime);\n    }\n    if (config.hasOwnProperty('birthtime')) {\n      dir.setBirthtime(config.birthtime);\n    }\n    return dir;\n  };\n};\n\n\n/**\n * Module exports.\n * @type {function}\n */\nvar exports = module.exports = FileSystem;\nexports.getPathParts = getPathParts;\n","/home/travis/build/npmtest/node-npmtest-mock-fs/node_modules/mock-fs/benchmarks/read-integration-real.js":"var assert = require('assert');\nvar fs = require('fs');\nvar path = require('path');\n\nvar rimraf = require('rimraf');\n\nvar tmpPath = '.tmp';\n\n\n/**\n * Timed test.  This includes the setup and teardown as part of the overall\n * test time.\n * @param {function(Error)} done Callback.\n */\nexports.test = function(done) {\n  fs.mkdir(tmpPath, function(mkdirErr) {\n    assert.ifError(mkdirErr);\n    var tmpFile = path.join(tmpPath, 'foo-real.txt');\n    fs.writeFile(tmpFile, 'foo', function(writeErr) {\n      assert.ifError(writeErr);\n      fs.readFile(tmpFile, 'utf8', function(readErr, str) {\n        assert.ifError(readErr);\n        assert.equal(str, 'foo');\n        rimraf(tmpPath, done);\n      });\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-mock-fs/node_modules/mock-fs/benchmarks/read-real.js":"var assert = require('assert');\nvar fs = require('fs');\nvar path = require('path');\n\nvar rimraf = require('rimraf');\n\nvar tmpPath = '.tmp';\n\n\n/**\n * Test setup.  Not timed.\n * @param {function(Error)} done Callback.\n */\nexports.beforeEach = function(done) {\n  fs.mkdir(tmpPath, function(err) {\n    if (err) {\n      return done(err);\n    }\n    fs.writeFile(path.join(tmpPath, 'foo-real.txt'), 'foo', done);\n  });\n};\n\n\n/**\n * Timed test.\n * @param {function(Error)} done Callback.\n */\nexports.test = function(done) {\n  fs.readFile(path.join(tmpPath, 'foo-real.txt'), 'utf8', function(err, str) {\n    assert.ifError(err);\n    assert.equal(str, 'foo');\n    done();\n  });\n};\n\n\n/**\n * Test teardown.  Not timed.\n * @param {function(Error)} done Callback.\n */\nexports.afterEach = function(done) {\n  rimraf(tmpPath, done);\n};\n","/home/travis/build/npmtest/node-npmtest-mock-fs/node_modules/mock-fs/benchmarks/write-integration-real.js":"var assert = require('assert');\nvar fs = require('fs');\nvar path = require('path');\n\nvar rimraf = require('rimraf');\n\nvar tmpPath = '.tmp';\n\n\n/**\n * Timed test.  This includes the setup and teardown as part of the overall\n * test time.\n * @param {function(Error)} done Callback.\n */\nexports.test = function(done) {\n  fs.mkdir(tmpPath, function(mkdirErr) {\n    assert.ifError(mkdirErr);\n    fs.writeFile(path.join(tmpPath, 'foo-real.txt'), 'foo', function(err) {\n      assert.ifError(err);\n      rimraf(tmpPath, done);\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-mock-fs/node_modules/mock-fs/benchmarks/write-real.js":"var fs = require('fs');\nvar path = require('path');\n\nvar rimraf = require('rimraf');\n\nvar tmpPath = '.tmp';\n\n\n/**\n * Test setup.  Not timed.\n * @param {function(Error)} done Callback.\n */\nexports.beforeEach = function(done) {\n  fs.mkdir(tmpPath, done);\n};\n\n\n/**\n * Timed test.\n * @param {function(Error)} done Callback.\n */\nexports.test = function(done) {\n  fs.writeFile(path.join(tmpPath, 'foo-real.txt'), 'foo', done);\n};\n\n\n/**\n * Test teardown.  Not timed.\n * @param {function(Error)} done Callback.\n */\nexports.afterEach = function(done) {\n  rimraf(tmpPath, done);\n};\n"}